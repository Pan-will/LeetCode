"""
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

注意:
num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。

示例 1 :
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。

示例 2 :
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
"""


# 思路：贪心算法 + 栈
# 从高位到低位，即从左往右遍历各个数字，依次入栈；
# 对于整数要明确一点：高位数字大于低位数字，那么删除该高位，结果一定变小，否则删除后不一定使结果最小。
# 例如425，2小于4，删除高位4后，结果一定变小；然而对于465，删除4结果不一定变小（65显然不是最优解，应删除6，得到45正解）。
#   若当前数字大于栈顶数字，则入栈——删除当前数字不一定使结果最小；
#   若当前数字小于栈顶数字，则栈顶元素出栈，每出栈一个元素（相当于删除一个数字）k要减1；
#   若当前数字等于栈顶数字，这种情况要结合k和遍历是否完成做特判。
class Solution(object):
    def removeKdigits(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        stack = []
        for digit in num:
            # 当栈不空、k大于0，且栈顶元素大于当前数字时，出栈，k-=1
            while k and stack and stack[-1] > digit:
                stack.pop(-1)
                k -= 1
            # 否则，当前数字进栈
            stack.append(digit)
        if k:
            stack = stack[:-k]
        # 返回时抹去前导0，若抹去后结果为空，则返回“0”
        return "".join(stack).lstrip("0") or "0"



if __name__ == '__main__':
    s = Solution()
    print(s.removeKdigits(num="10000", k=1))
