<br/>

### 代码一：暴力超时了。

```python
class Solution(object):
    # 暴力超时
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        if not T:
            return []
        res = []
        for i in range(len(T)):
            temp = T[i:]
            if not temp:
                break
            for j in range(1, len(temp)):
                if temp[j] > T[i]:
                    res.append(j)
                    break
                if j == len(temp) - 1:
                    res.append(0)
                    break
        res.append(0)
        return res
```

<br/>

### 代码二：单调栈

思路：

注意题目说的是更高的气温，而不是最高的气温。因此，只要找到原list中在当前元素后面且比当前元素大的位置的下标，赋值即可。

```python
class Solution(object):
    # 单调栈。
    # 遍历T，维护一个栈，栈空或者当前元素比栈顶小，则入栈，否则栈顶出栈，并在res中记录栈顶元素位置的答案。
    # 注意栈中存放的应该是每个元素的下标。
    def dailyTemperatures(self, T):
        """
        :type T: List[int]
        :rtype: List[int]
        """
        if not T:
            return []
        lenT = len(T)
        # 返回值
        res = [0] * lenT
        stack = []
        for index, curT in enumerate(T):
            while stack and curT > T[stack[-1]]:
                temp = stack.pop()
                res[temp] = index - temp
            stack.append(index)
        return res
```

<br/>

### 用list返回二叉树的所有路径。

```python
class Solution(object):
    # 前序式DFS——用list返回二叉树的所有路径
    # 注意每趟递归前要将当前节点pop()掉
    def pre_DFS(self, node, res, road):
        # 当前节点为空，直接return
        if not node:
            return
        # 否则将当前节点加入路径中
        road.append(node.val)
        # 当前节点是叶子则将路径加入外层list中
        if not node.left and not node.right:
            res.append(list(road))
        # 前序式递归当前节点的左右子树
        self.pre_DFS(node.left, res, road)
        self.pre_DFS(node.right, res, road)
        # 每趟递归前将当前节点pop()
        road.pop()
        # 返回外层list
        return res
```

